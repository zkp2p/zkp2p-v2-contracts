{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "contracts/external/Bytes32ArrayUtils.sol": {
      "content": "//SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.17;\n\n/**\n * @title Bytes32ArrayUtils\n * @author ZKP2P\n *\n * Fork of Set Protocol's AddressArrayUtils library adapted for usage with bytes32 arrays.\n */\nlibrary Bytes32ArrayUtils {\n\n    uint256 constant internal MAX_INT = 2**256 - 1;\n\n    /**\n     * Finds the index of the first occurrence of the given element.\n     * @param A The input array to search\n     * @param a The value to find\n     * @return Returns (index and isIn) for the first occurrence starting from index 0\n     */\n    function indexOf(bytes32[] memory A, bytes32 a) internal pure returns (uint256, bool) {\n        uint256 length = A.length;\n        for (uint256 i = 0; i < length; i++) {\n            if (A[i] == a) {\n                return (i, true);\n            }\n        }\n        return (MAX_INT, false);\n    }\n\n    /**\n    * Returns true if the value is present in the list. Uses indexOf internally.\n    * @param A The input array to search\n    * @param a The value to find\n    * @return Returns isIn for the first occurrence starting from index 0\n    */\n    function contains(bytes32[] memory A, bytes32 a) internal pure returns (bool) {\n        (, bool isIn) = indexOf(A, a);\n        return isIn;\n    }\n\n    /**\n    * Returns true if there are 2 elements that are the same in an array\n    * @param A The input array to search\n    * @return Returns boolean for the first occurrence of a duplicate\n    */\n    function hasDuplicate(bytes32[] memory A) internal pure returns(bool) {\n        require(A.length > 0, \"A is empty\");\n\n        for (uint256 i = 0; i < A.length - 1; i++) {\n            bytes32 current = A[i];\n            for (uint256 j = i + 1; j < A.length; j++) {\n                if (current == A[j]) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    /**\n     * @param A The input array to search\n     * @param a The bytes32 to remove\n     * @return Returns the array with the object removed.\n     */\n    function remove(bytes32[] memory A, bytes32 a)\n        internal\n        pure\n        returns (bytes32[] memory)\n    {\n        (uint256 index, bool isIn) = indexOf(A, a);\n        if (!isIn) {\n            revert(\"bytes32 not in array.\");\n        } else {\n            (bytes32[] memory _A,) = pop(A, index);\n            return _A;\n        }\n    }\n\n    /**\n     * @param A The input array to search\n     * @param a The bytes32 to remove\n     */\n    function removeStorage(bytes32[] storage A, bytes32 a)\n        internal\n    {\n        (uint256 index, bool isIn) = indexOf(A, a);\n        if (!isIn) {\n            revert(\"bytes32 not in array.\");\n        } else {\n            uint256 lastIndex = A.length - 1; // If the array would be empty, the previous line would throw, so no underflow here\n            if (index != lastIndex) { A[index] = A[lastIndex]; }\n            A.pop();\n        }\n    }\n\n    /**\n    * Removes specified index from array\n    * @param A The input array to search\n    * @param index The index to remove\n    * @return Returns the new array and the removed entry\n    */\n    function pop(bytes32[] memory A, uint256 index)\n        internal\n        pure\n        returns (bytes32[] memory, bytes32)\n    {\n        uint256 length = A.length;\n        require(index < A.length, \"Index must be < A length\");\n        bytes32[] memory newBytes = new bytes32[](length - 1);\n        for (uint256 i = 0; i < index; i++) {\n            newBytes[i] = A[i];\n        }\n        for (uint256 j = index + 1; j < length; j++) {\n            newBytes[j - 1] = A[j];\n        }\n        return (newBytes, A[index]);\n    }\n}\n"
    },
    "contracts/interfaces/IAttestationVerifier.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\n/**\n * @title IAttestationVerifier\n * @notice Interface for verifying attestations from various sources (witnesses, TEE, etc.)\n */\ninterface IAttestationVerifier {\n    /**\n     * @notice Verifies attestations for a given digest\n     * @param _digest The message digest to verify (EIP-712 formatted)\n     * @param _sigs Array of signatures from attestors\n     * @param _data Verification data containing attestor identities or hints\n     * @return isValid Returns true if the attestation is valid, false otherwise\n     */\n    function verify(\n        bytes32 _digest,\n        bytes[] calldata _sigs,\n        bytes calldata _data\n    ) external view returns (bool isValid);\n}"
    },
    "contracts/interfaces/IEscrow.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.18;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { IPostIntentHook } from \"./IPostIntentHook.sol\";\n\ninterface IEscrow {\n    \n    /* ============ Structs ============ */\n\n    struct Intent {\n        bytes32 intentHash;                        // Unique identifier for the intent\n        uint256 amount;                            // Amount locked\n        uint256 timestamp;                         // When this intent was created\n        uint256 expiryTime;                        // When this intent expires\n    }\n\n    struct Range {\n        uint256 min;                                // Minimum value\n        uint256 max;                                // Maximum value\n    }\n\n    struct Deposit {\n        address depositor;                          // Address of depositor\n        address delegate;                           // Address that can manage this deposit (address(0) if no delegate)\n        IERC20 token;                               // Address of deposit token\n        uint256 amount;                             // Amount of deposit token (gross amount including reserved fees)\n        Range intentAmountRange;                    // Range of take amount per intent\n        // Deposit state\n        bool acceptingIntents;                      // State: True if the deposit is accepting intents, False otherwise\n        uint256 remainingDeposits;                  // State: Amount of remaining deposited liquidity (net of reserved fees)\n        uint256 outstandingIntentAmount;            // State: Amount of outstanding intents (may include expired intents)\n        // Fee tracking\n        uint256 makerProtocolFee;                   // State: Maker protocol fee at the time of deposit creation in preciseUnits  (1e16 = 1%)\n        uint256 reservedMakerFees;                  // State: Total fees reserved from maker (calculated upfront)\n        uint256 accruedMakerFees;                   // State: Fees actually earned from fulfilled intents\n        uint256 accruedReferrerFees;               // State: Referrer fees actually earned from fulfilled intents\n        // Intent guardian\n        address intentGuardian;                     // Address that can extend intent expiry times (address(0) if no guardian)\n        // Referrer\n        address referrer;                           // Address of the referrer who brought this deposit (address(0) if no referrer)\n        uint256 referrerFee;                        // Fee to be paid to the referrer in preciseUnits (1e16 = 1%)\n    }\n\n    struct Currency {\n        bytes32 code;                               // Currency code (keccak256 hash of the currency code)\n        uint256 minConversionRate;                  // Minimum rate of deposit token to fiat currency (in preciseUnits)\n    }\n\n    struct DepositPaymentMethodData {\n        address intentGatingService;                // Public key of gating service that will be used to verify intents\n        bytes32 payeeDetails;                       // Payee details, has to be hash of payee details\n        bytes data;                                 // Verification Data: Additional data used for payment verification; Can hold attester address\n                                                    // in case of TLS proofs, domain key hash in case of zkEmail proofs, currency code etc.\n    }\n\n    struct CreateDepositParams {\n        IERC20 token;                                // The token to be deposited\n        uint256 amount;                              // The amount of token to deposit\n        Range intentAmountRange;                     // The max and min take amount for each intent\n        bytes32[] paymentMethods;                    // The payment methods that deposit supports\n        DepositPaymentMethodData[] paymentMethodData;// The payment verification data for each payment method that deposit supports\n        Currency[][] currencies;                     // The currencies for each payment method that deposit supports\n        address delegate;                            // Optional delegate address that can manage this deposit (address(0) for no delegate)\n        address intentGuardian;                      // Optional intent guardian address that can extend intent expiry times (address(0) for no guardian)\n        address referrer;                            // Address of the referrer who brought this deposit (address(0) if no referrer)\n        uint256 referrerFee;                         // Fee to be paid to the referrer in preciseUnits (1e16 = 1%)\n    }\n\n    /* ============ Events ============ */\n\n    event DepositReceived(uint256 indexed depositId, address indexed depositor, IERC20 indexed token, uint256 amount, uint256 netDepositAmount, Range intentAmountRange, address delegate, address intentGuardian);\n\n    event DepositPaymentMethodAdded(uint256 indexed depositId, bytes32 indexed paymentMethod, bytes32 indexed payeeDetails, address intentGatingService);\n    event DepositPaymentMethodRemoved(uint256 indexed depositId, bytes32 indexed paymentMethod);\n\n    event DepositCurrencyAdded(uint256 indexed depositId, bytes32 indexed paymentMethod, bytes32 indexed currency, uint256 minConversionRate);\n    event DepositCurrencyRemoved(uint256 indexed depositId, bytes32 indexed paymentMethod, bytes32 indexed currencyCode);        \n\n    event DepositFundsAdded(uint256 indexed depositId, address indexed depositor, uint256 amount, uint256 netAdditionalAmount);\n    event DepositWithdrawn(uint256 indexed depositId, address indexed depositor, uint256 amount, bool acceptingIntents);\n    event DepositClosed(uint256 depositId, address depositor);\n\n    event DepositIntentAmountRangeUpdated(uint256 indexed depositId, Range intentAmountRange);\n    event DepositMinConversionRateUpdated(uint256 indexed depositId, bytes32 indexed paymentMethod, bytes32 indexed currency, uint256 newMinConversionRate);\n    event DepositAcceptingIntentsUpdated(uint256 indexed depositId, bool acceptingIntents);\n\n    event DepositDelegateSet(uint256 indexed depositId, address indexed depositor, address indexed delegate);\n    event DepositDelegateRemoved(uint256 indexed depositId, address indexed depositor);\n\n    event MinDepositAmountSet(uint256 minDepositAmount);\n\n    event OrchestratorUpdated(address indexed orchestrator);\n    event PaymentVerifierRegistryUpdated(address indexed paymentVerifierRegistry);\n\n    event FundsLocked(uint256 indexed depositId, bytes32 indexed intentHash, uint256 amount, uint256 expiryTime);\n    event FundsUnlocked(uint256 indexed depositId, bytes32 indexed intentHash, uint256 amount);\n    event FundsUnlockedAndTransferred(\n        uint256 indexed depositId, \n        bytes32 indexed intentHash, \n        uint256 unlockedAmount, \n        uint256 transferredAmount, \n        uint256 makerFees, \n        uint256 referrerFees, \n        address to\n    );\n    event IntentExpiryExtended(uint256 indexed depositId, bytes32 indexed intentHash, uint256 newExpiryTime);\n\n    event MakerProtocolFeeUpdated(uint256 makerProtocolFee);\n    event MakerFeeRecipientUpdated(address indexed makerFeeRecipient);\n    event MakerFeesCollected(uint256 indexed depositId, uint256 collectedFees, address indexed makerFeeRecipient);\n    event ReferrerFeesCollected(uint256 indexed depositId, uint256 collectedFees, address indexed referrer);\n    event DustCollected(uint256 indexed depositId, uint256 dustAmount, address indexed makerFeeRecipient);\n    event DustThresholdUpdated(uint256 dustThreshold);\n    event MaxIntentsPerDepositUpdated(uint256 maxIntentsPerDeposit);\n    event IntentExpirationPeriodUpdated(uint256 intentExpirationPeriod);\n\n    /* ============ Standardized Custom Errors ============ */\n    \n    // Zero value errors\n    error ZeroAddress();\n    error ZeroValue();\n    error ZeroMinValue();\n    error ZeroConversionRate();\n\n    // Authorization errors\n    error UnauthorizedCaller(address caller, address authorized);\n    error UnauthorizedCallerOrDelegate(address caller, address owner, address delegate);\n\n    // Range and amount errors\n    error InvalidRange(uint256 min, uint256 max);\n    error AmountBelowMin(uint256 amount, uint256 min);\n    error AmountAboveMax(uint256 amount, uint256 max);\n    error AmountExceedsAvailable(uint256 requested, uint256 available);\n    error FeeExceedsMaximum(uint256 fee, uint256 maximum);\n\n    // Not found errors\n    error DepositNotFound(uint256 depositId);\n    error IntentNotFound(bytes32 intentHash);\n    error PaymentMethodNotFound(uint256 depositId, bytes32 paymentMethod);\n    error CurrencyNotFound(bytes32 paymentMethod, bytes32 currency);\n    error DelegateNotFound(uint256 depositId);\n\n    // Already exists errors\n    error PaymentMethodAlreadyExists(uint256 depositId, bytes32 paymentMethod);\n    error CurrencyAlreadyExists(bytes32 paymentMethod, bytes32 currency);\n\n    // State errors\n    error DepositNotAcceptingIntents(uint256 depositId);\n    error DepositAlreadyInState(uint256 depositId, bool currentState);\n    error InsufficientDepositLiquidity(uint256 depositId, uint256 available, uint256 required);\n    error MaxIntentsExceeded(uint256 depositId, uint256 current, uint256 max);\n\n    // Validation errors\n    error EmptyPayeeDetails();\n    error ArrayLengthMismatch(uint256 length1, uint256 length2);\n    error InvalidReferrerFeeConfiguration();\n\n    // Payment method errors\n    error PaymentMethodNotWhitelisted(bytes32 paymentMethod);\n    error CurrencyNotSupported(bytes32 paymentMethod, bytes32 currency);\n\n    \n    /* ============ External Functions for Orchestrator ============ */\n\n    function lockFunds(uint256 _depositId, bytes32 _intentHash, uint256 _amount) external;\n    function unlockFunds(uint256 _depositId, bytes32 _intentHash) external;\n    function unlockAndTransferFunds(uint256 _depositId, bytes32 _intentHash, uint256 _transferAmount, address _to) external;\n    function extendIntentExpiry(uint256 _depositId, bytes32 _intentHash, uint256 _newExpiryTime) external;\n\n    /* ============ View Functions ============ */\n\n    function getDeposit(uint256 _depositId) external view returns (Deposit memory);\n    function getDepositIntent(uint256 _depositId, bytes32 _intentHash) external view returns (Intent memory);\n    function getDepositPaymentMethods(uint256 _depositId) external view returns (bytes32[] memory);\n    function getDepositCurrencies(uint256 _depositId, bytes32 _paymentMethod) external view returns (bytes32[] memory);\n    function getDepositCurrencyMinRate(uint256 _depositId, bytes32 _paymentMethod, bytes32 _currencyCode) external view returns (uint256);\n    function getDepositPaymentMethodData(uint256 _depositId, bytes32 _paymentMethod) external view returns (DepositPaymentMethodData memory);\n    function getAccountDeposits(address _account) external view returns (uint256[] memory);\n    function getDepositIntentHashes(uint256 _depositId) external view returns (bytes32[] memory);\n    function getExpiredIntents(uint256 _depositId) external view returns (bytes32[] memory expiredIntents, uint256 reclaimedAmount);\n}\n"
    },
    "contracts/interfaces/INullifierRegistry.sol": {
      "content": "//SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.18;\n\ninterface INullifierRegistry {\n    function addNullifier(bytes32 _nullifier) external;\n    function isNullified(bytes32 _nullifier) external view returns(bool);\n}\n"
    },
    "contracts/interfaces/IOrchestrator.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.18;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { IPostIntentHook } from \"./IPostIntentHook.sol\";\n\ninterface IOrchestrator {\n    \n    /* ============ Structs ============ */\n\n    struct Intent {\n        address owner;                              // Address of the intent owner  \n        address to;                                 // Address to forward funds to (can be same as owner)\n        address escrow;                             // Address of the escrow contract holding the deposit\n        uint256 depositId;                          // ID of the deposit the intent is associated with\n        uint256 amount;                             // Amount of the deposit.token the owner wants to take\n        uint256 timestamp;                          // Timestamp of the intent\n        bytes32 paymentMethod;                      // The payment method to be used for the offchain payment\n        bytes32 fiatCurrency;                       // Currency code that the owner is paying in offchain (keccak256 hash of the currency code)\n        uint256 conversionRate;                     // Conversion rate of deposit token to fiat currency at the time of intent\n        address referrer;                           // Address of the referrer who brought this intent (if any)\n        uint256 referrerFee;                        // Fee to be paid to the referrer in preciseUnits (1e16 = 1%)\n        IPostIntentHook postIntentHook;             // Address of the post-intent hook that will execute any post-intent actions\n        bytes data;                                 // Additional data to be passed to the post-intent hook contract\n    }\n\n    struct SignalIntentParams {\n        address escrow;                             // The escrow contract where the deposit is held\n        uint256 depositId;                          // The ID of the deposit the taker intends to use\n        uint256 amount;                             // The amount of deposit.token the user wants to take\n        address to;                                 // Address to forward funds to\n        bytes32 paymentMethod;                      // The payment method to be used for the offchain payment\n        bytes32 fiatCurrency;                       // The currency code for offchain payment\n        uint256 conversionRate;                     // The conversion rate agreed offchain\n        address referrer;                           // Address of the referrer (address(0) if no referrer)\n        uint256 referrerFee;                        // Fee to be paid to the referrer\n        bytes gatingServiceSignature;               // Signature from the deposit's gating service\n        uint256 signatureExpiration;                // Timestamp when the gating service signature expires\n        IPostIntentHook postIntentHook;             // Optional post-intent hook (address(0) for no hook)\n        bytes data;                                 // Additional data for the intent\n    }\n\n    struct FulfillIntentParams {\n        bytes paymentProof;                         // Payment proof. Can be Groth16 Proof, TLSNotary proof, TLSProxy proof, attestation etc.\n        bytes32 intentHash;                         // Identifier of intent being fulfilled\n        bytes verificationData;                     // Additional data for payment verifier\n        bytes postIntentHookData;                   // Additional data for post intent hook\n    }\n\n    /* ============ Events ============ */\n\n    event IntentSignaled(\n        bytes32 indexed intentHash, \n        address indexed escrow,\n        uint256 indexed depositId, \n        bytes32 paymentMethod, \n        address owner, \n        address to, \n        uint256 amount, \n        bytes32 fiatCurrency, \n        uint256 conversionRate, \n        uint256 timestamp\n    );\n\n    event IntentPruned(\n        bytes32 indexed intentHash\n    );\n\n    event IntentFulfilled(\n        bytes32 indexed intentHash,\n        address indexed fundsTransferredTo,   // Address that funds were transferred to; can be intent.to or postIntentHook address\n        uint256 amount,\n        bool isManualRelease\n    );\n\n    event AllowMultipleIntentsUpdated(bool allowMultiple);\n\n    event PaymentVerifierRegistryUpdated(address indexed paymentVerifierRegistry);\n    event PostIntentHookRegistryUpdated(address indexed postIntentHookRegistry);\n    event RelayerRegistryUpdated(address indexed relayerRegistry);\n    event EscrowRegistryUpdated(address indexed escrowRegistry);\n\n    event ProtocolFeeUpdated(uint256 protocolFee);\n    event ProtocolFeeRecipientUpdated(address indexed protocolFeeRecipient);\n    event PartialManualReleaseDelayUpdated(uint256 partialManualReleaseDelay);\n\n    /* ============ Standardized Custom Errors ============ */\n    \n    // Zero value errors\n    error ZeroAddress();\n    error ZeroValue();\n    \n    // Authorization errors\n    error UnauthorizedEscrowCaller(address caller);\n    error UnauthorizedCaller(address caller, address authorized);\n    \n    // Not found errors\n    error IntentNotFound(bytes32 intentHash);\n    error PaymentMethodDoesNotExist(bytes32 paymentMethod);\n    error PaymentMethodNotSupported(bytes32 paymentMethod);\n    error CurrencyNotSupported(bytes32 paymentMethod, bytes32 currency);\n    \n    // Whitelist errors\n    error PaymentMethodNotWhitelisted(bytes32 paymentMethod);\n    error PostIntentHookNotWhitelisted(address hook);\n    error EscrowNotWhitelisted(address escrow);\n    \n    // Amount and fee errors\n    error AmountBelowMin(uint256 amount, uint256 min);\n    error AmountAboveMax(uint256 amount, uint256 max);\n    error AmountExceedsLimit(uint256 amount, uint256 limit);\n    error FeeExceedsMaximum(uint256 fee, uint256 maximum);\n    error RateBelowMinimum(uint256 rate, uint256 minRate);\n    \n    // Validation errors\n    error AccountHasActiveIntent(address account, bytes32 existingIntent);\n    error InvalidReferrerFeeConfiguration();\n    error InvalidSignature();\n    error SignatureExpired(uint256 expiration, uint256 currentTime);\n    error PartialReleaseNotAllowedYet(uint256 currentTime, uint256 allowedTime);\n\n    // Verification errors\n    error PaymentVerificationFailed();\n    error HashMismatch(bytes32 expected, bytes32 actual);\n     \n    // Transfer errors\n    error TransferFailed(address recipient, uint256 amount);\n    error EscrowLockFailed();\n\n    /* ============ View Functions ============ */\n\n    function getIntent(bytes32 intentHash) external view returns (Intent memory);\n    function getAccountIntents(address account) external view returns (bytes32[] memory);\n    \n    /* ============ External Functions for Users ============ */\n\n    function signalIntent(SignalIntentParams calldata params) external;\n\n    function cancelIntent(bytes32 intentHash) external;\n\n    function fulfillIntent(FulfillIntentParams calldata params) external;\n\n    function releaseFundsToPayer(bytes32 intentHash) external;\n\n    /* ============ External Functions for Escrow ============ */\n\n    function pruneIntents(bytes32[] calldata intentIds) external;\n}"
    },
    "contracts/interfaces/IPaymentVerifier.sol": {
      "content": "//SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.18;\n\n\ninterface IPaymentVerifier {\n\n    /* ============ Structs ============ */\n\n    struct VerifyPaymentData {\n        bytes32 intentHash;                     // The hash of the intent being fulfilled\n        bytes paymentProof;                     // Payment proof\n        bytes data;                             // Additional data provided by the taker\n    }\n\n    struct PaymentVerificationResult {\n        bool success;                           // Whether the payment verification succeeded\n        bytes32 intentHash;                     // The hash of the intent being fulfilled\n        uint256 releaseAmount;                  // The amount of tokens to release\n    }\n\n    /* ============ External Functions ============ */\n\n    function verifyPayment(\n        VerifyPaymentData calldata _verifyPaymentData\n    )   \n        external\n        returns(PaymentVerificationResult memory result);\n\n}\n"
    },
    "contracts/interfaces/IPostIntentHook.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.18;\n\nimport { IOrchestrator } from \"./IOrchestrator.sol\";\n\n/**\n * @title IPostIntentHook\n * @notice Interface for post-intent hooks\n */\ninterface IPostIntentHook {\n\n    /**\n     * @notice Post-intent hook\n     * @param _intent The intent data structure containing all intent information\n     * @param _fulfillIntentData The data passed to fulfillIntent\n     */\n    function execute(\n        IOrchestrator.Intent memory _intent,\n        uint256 _amountNetFees,\n        bytes calldata _fulfillIntentData\n    ) external;\n}\n"
    },
    "contracts/unifiedVerifier/BaseUnifiedPaymentVerifier.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport { Bytes32ArrayUtils } from \"../external/Bytes32ArrayUtils.sol\";\nimport { IAttestationVerifier } from \"../interfaces/IAttestationVerifier.sol\";\nimport { INullifierRegistry } from \"../interfaces/INullifierRegistry.sol\";\nimport { IOrchestrator } from \"../interfaces/IOrchestrator.sol\";\n\n/**\n * @title BaseUnifiedPaymentVerifier\n * @notice Base contract for unified payment verification that manages configuration for multiple payment methods.\n * \n * This contract handles:\n * - Supported payment methods\n * - Attestation verification through pluggable attestation verifiers\n * \n * @dev This is an abstract contract that must be inherited by concrete implementations.\n *      It replaces the previous BaseReclaimVerifier with a more flexible architecture.\n */\nabstract contract BaseUnifiedPaymentVerifier is Ownable {\n    \n    using Bytes32ArrayUtils for bytes32[];\n    \n    /* ============ Constants ============ */\n\n    uint256 internal constant PRECISE_UNIT = 1e18;\n\n    /* ============ Events ============ */\n    \n    event PaymentMethodAdded(bytes32 indexed paymentMethod);\n    event PaymentMethodRemoved(bytes32 indexed paymentMethod);\n    event AttestationVerifierUpdated(address indexed oldVerifier, address indexed newVerifier);\n\n    /* ============ State Variables ============ */\n    \n    IOrchestrator public immutable orchestrator;\n    INullifierRegistry public immutable nullifierRegistry;\n    IAttestationVerifier public attestationVerifier;\n\n    bytes32[] public paymentMethods;\n    mapping(bytes32 => bool) public isPaymentMethod;\n    \n    /* ============ Modifiers ============ */\n\n    /**\n     * Modifier to ensure only escrow can call\n     */\n    modifier onlyOrchestrator() {\n        require(msg.sender == address(orchestrator), \"Only orchestrator can call\");\n        _;\n    }\n\n    /* ============ Constructor ============ */\n    \n    /**\n     * @notice Initializes base payment verifier\n     * @param _orchestrator The orchestrator contract address that will be used to verify payments\n     * @param _nullifierRegistry The nullifier registry contract that will be used to prevent double-spends\n     * @param _attestationVerifier The attestation verifier contract that will be used to verify attestation by the\n     * offchain / ZK attestation service\n     */\n    constructor(\n        IOrchestrator _orchestrator,\n        INullifierRegistry _nullifierRegistry,\n        IAttestationVerifier _attestationVerifier\n    ) Ownable() {\n        orchestrator = _orchestrator;\n        nullifierRegistry = _nullifierRegistry;\n        attestationVerifier = _attestationVerifier;\n    }\n    \n    /* ============ External Functions ============ */\n    \n    /**\n     * ONLY OWNER: Adds a new payment method with timestamp buffer\n     * @param _paymentMethod The payment method hash; Hash the payment method name in lowercase\n     */\n    function addPaymentMethod(bytes32 _paymentMethod) external onlyOwner {\n        require(!isPaymentMethod[_paymentMethod], \"UPV: Payment method already exists\");\n        \n        isPaymentMethod[_paymentMethod] = true;\n        paymentMethods.push(_paymentMethod);\n        \n        emit PaymentMethodAdded(_paymentMethod);\n    }\n    \n    /**\n     * ONLY OWNER: Removes a payment method and associated configuration\n     * @param _paymentMethod The payment method to remove\n     */\n    function removePaymentMethod(bytes32 _paymentMethod) external onlyOwner {\n        require(isPaymentMethod[_paymentMethod], \"UPV: Payment method does not exist\");\n        \n        delete isPaymentMethod[_paymentMethod];\n        paymentMethods.removeStorage(_paymentMethod);\n        \n        emit PaymentMethodRemoved(_paymentMethod);\n    }\n    \n    /**\n     * @notice Updates the attestation verifier contract\n     * @param _newVerifier The new attestation verifier address\n     */\n    function setAttestationVerifier(address _newVerifier) external onlyOwner {\n        address oldVerifier = address(attestationVerifier);\n        require(_newVerifier != address(0), \"UPV: Invalid attestation verifier\");\n        require(_newVerifier != oldVerifier, \"UPV: Same verifier\");\n        \n        attestationVerifier = IAttestationVerifier(_newVerifier);\n        emit AttestationVerifierUpdated(oldVerifier, _newVerifier);\n    }\n                                                                                                               \n    \n    /* ============ View Functions ============ */\n    \n    function getPaymentMethods() external view returns (bytes32[] memory) {\n        return paymentMethods;\n    }\n    \n    /* ============ Internal Functions ============ */\n    \n    /**\n     * Validates and adds a nullifier to prevent double-spending\n     * @param _nullifier The nullifier to add\n     */\n    function _validateAndAddNullifier(bytes32 _nullifier) internal {\n        require(!nullifierRegistry.isNullified(_nullifier), \"Nullifier has already been used\");\n        nullifierRegistry.addNullifier(_nullifier);\n    }\n}\n"
    },
    "contracts/unifiedVerifier/UnifiedPaymentVerifier.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport { BaseUnifiedPaymentVerifier } from \"./BaseUnifiedPaymentVerifier.sol\";\nimport { INullifierRegistry } from \"../interfaces/INullifierRegistry.sol\";\nimport { IPaymentVerifier } from \"../interfaces/IPaymentVerifier.sol\";\nimport { IAttestationVerifier } from \"../interfaces/IAttestationVerifier.sol\";\nimport { IOrchestrator } from \"../interfaces/IOrchestrator.sol\";\nimport { IEscrow } from \"../interfaces/IEscrow.sol\";\n\n/**\n * @title UnifiedPaymentVerifier\n * @notice Verifies payment proofs for multiple payment methods. This is a unified verifier that \n * replaces individual payment verifiers (VenmoVerifier, PayPalVerifier, etc.) with a single \n * configurable contract.\n * \n * Key features:\n * - Supports multiple payment methods, each with custom configuration\n * - Uses AttestationVerifier to validate offchain payment attestations   \n * - Ensures trust anchor integrity for off-chain verification processes\n * - Verifies standardized payment details against provided data\n * @dev The payment attestation should be signed using the EIP-712 standard\n */\ncontract UnifiedPaymentVerifier is IPaymentVerifier, BaseUnifiedPaymentVerifier {\n\n    /* ============ Constants ============ */\n    \n    // Max timestamp buffer\n    uint256 private constant MAX_TIMESTAMP_BUFFER = 48 * 60 * 60 * 1000; // 48 hours\n\n    // EIP-712 Domain Separator\n    bytes32 private constant DOMAIN_TYPEHASH = keccak256(\n        \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"\n    );\n    \n    // EIP-712 Type Hash for PaymentAttestation\n    bytes32 private constant PAYMENT_ATTESTATION_TYPEHASH = keccak256(\n        \"PaymentAttestation(bytes32 intentHash,uint256 releaseAmount,bytes32 dataHash)\"\n    );\n\n    /* ============ State Variables ============ */\n\n    // EIP-712 Domain Separator (computed once at deployment)\n    bytes32 public immutable DOMAIN_SEPARATOR;\n\n    /* ============ Events ============ */\n\n    /**\n     * @notice Capture and emit payment details for offchain reconciliation\n     */\n    event PaymentVerified(\n        bytes32 indexed intentHash,\n        bytes32 indexed method,\n        bytes32 indexed currency,\n        uint256 amount,\n        uint256 timestamp,\n        bytes32 paymentId,\n        bytes32 payeeId\n    );\n\n    /* ============ Structs ============ */\n\n    struct PaymentDetails {\n        bytes32 method;           // Payment method hash (e.g., \"venmo\", \"paypal\", \"wise\")\n        bytes32 payeeId;          // Payment recipient ID (hashed payee details to preserve privacy)\n        uint256 amount;           // Payment amount in smallest currency unit (i.e. cents)\n        bytes32 currency;         // Payment currency hash (e.g., \"USD\", \"EUR\")\n        uint256 timestamp;        // Payment timestamp in UTC in milliseconds\n        bytes32 paymentId;        // Hashed payment identifier from the service (e.g. hashed venmo payment ID to preserve privacy)\n    }\n\n    struct IntentSnapshot {\n        bytes32 intentHash;\n        uint256 amount;\n        bytes32 paymentMethod;\n        bytes32 fiatCurrency;\n        bytes32 payeeDetails;\n        uint256 conversionRate;\n        uint256 signalTimestamp;\n        uint256 timestampBuffer;\n    }\n\n    struct PaymentAttestation {\n        bytes32 intentHash;       // Binds the payment to the intent on Orchestrator\n        uint256 releaseAmount;    // Final token amount to release on-chain after FX\n        bytes32 dataHash;         // Hash of the additional data to verify integrity\n        bytes[] signatures;       // Array of signatures from witnesses\n        bytes data;               // Data for verification\n        bytes metadata;           // Additional metadata; isn't signed by the witnesses\n    }\n\n    /* ============ Constructor ============ */\n    \n    constructor(\n        IOrchestrator _orchestrator,\n        INullifierRegistry _nullifierRegistry,\n        IAttestationVerifier _attestationVerifier\n    ) BaseUnifiedPaymentVerifier(\n        _orchestrator,\n        _nullifierRegistry,\n        _attestationVerifier\n    ) {\n        // Compute EIP-712 domain separator\n        DOMAIN_SEPARATOR = keccak256(\n            abi.encode(\n                DOMAIN_TYPEHASH,\n                keccak256(bytes(\"UnifiedPaymentVerifier\")), // name\n                keccak256(bytes(\"1\")),                      // version\n                block.chainid,                              // chainId\n                address(this)                               // verifyingContract\n            )\n        );\n    }\n\n    /* ============ External Functions ============ */\n    \n    /**\n     * ONLY ORCHESTRATOR: Verifies a standardized payment attestation generated by the attestation service.\n     * \n     * @param _verifyPaymentData Payment proof and intent details required for verification\n     * @return result The payment verification result containing success status, intent hash, and release amount\n     * @dev Ensure the orchestrator verifies the intent exists before calling this function\n     */\n    function verifyPayment(\n        VerifyPaymentData calldata _verifyPaymentData\n    )\n        external\n        override\n        onlyOrchestrator()\n        returns (PaymentVerificationResult memory result)\n    {\n        PaymentAttestation memory attestation = _decodeAttestation(_verifyPaymentData.paymentProof);\n        \n        (\n            PaymentDetails memory paymentDetails, \n            IntentSnapshot memory intentSnapshot\n        ) = _decodeAttestationPayload(attestation.data);\n        require(isPaymentMethod[paymentDetails.method], \"UPV: Invalid payment method\");\n        \n        _validateIntentSnapshot(_verifyPaymentData.intentHash, intentSnapshot);\n\n        bool isValid = _verifyAttestation(attestation);\n        require(isValid, \"UPV: Invalid attestation\");\n                \n        // Nullify the payment to prevent double-spending\n        _nullifyPayment(paymentDetails.method, paymentDetails.paymentId);\n        \n        _emitPaymentDetails(attestation.intentHash, paymentDetails);\n    \n        uint256 releaseAmount = _calculateReleaseAmount(attestation.releaseAmount, intentSnapshot.amount);\n\n        result = PaymentVerificationResult({\n            success: true,\n            intentHash: attestation.intentHash,\n            releaseAmount: releaseAmount\n        });\n\n        return result;\n    }\n\n    /* ============ Internal Functions ============ */\n\n    function _decodeAttestation(bytes memory paymentProof) internal pure returns (PaymentAttestation memory) {\n        return abi.decode(paymentProof, (PaymentAttestation));\n    }\n\n    function _decodeAttestationPayload(bytes memory paymentData)\n        internal\n        pure\n        returns (PaymentDetails memory paymentDetails, IntentSnapshot memory intentSnapshot)\n    {\n        (paymentDetails, intentSnapshot) = abi.decode(paymentData, (PaymentDetails, IntentSnapshot));\n    }\n\n    /**\n     * Verifies the EIP-712 attestation using the attestation verifier. Also verifies the integrity of the \n     * verify payment data using the data hash attached to the attestation.\n     */\n    function _verifyAttestation(PaymentAttestation memory attestation) internal view returns (bool) {\n        bytes32 structHash = keccak256(\n            abi.encode(\n                PAYMENT_ATTESTATION_TYPEHASH,\n                attestation.intentHash,\n                attestation.releaseAmount,\n                attestation.dataHash\n            )\n        );\n        \n        bytes32 digest = keccak256(\n            abi.encodePacked(\n                \"\\x19\\x01\",\n                DOMAIN_SEPARATOR,\n                structHash\n            )\n        );\n\n        // Verify data integrity - the data hash must match what was signed\n        require(\n            keccak256(attestation.data) == attestation.dataHash,\n            \"UPV: Data hash mismatch\"\n        );\n\n        bool isValid = attestationVerifier.verify(\n            digest, \n            attestation.signatures,\n            attestation.data\n        );\n\n        return isValid;\n    }\n\n    function _validateIntentSnapshot(\n        bytes32 intentHash,\n        IntentSnapshot memory snapshot\n    ) internal view {\n        require(snapshot.intentHash == intentHash, \"UPV: Snapshot hash mismatch\");\n\n        IOrchestrator.Intent memory intent = IOrchestrator(orchestrator).getIntent(intentHash);\n        require(snapshot.amount == intent.amount, \"UPV: Snapshot amount mismatch\");\n        require(snapshot.paymentMethod == intent.paymentMethod, \"UPV: Snapshot method mismatch\");\n        require(snapshot.fiatCurrency == intent.fiatCurrency, \"UPV: Snapshot currency mismatch\");\n        require(snapshot.conversionRate == intent.conversionRate, \"UPV: Snapshot rate mismatch\");\n        require(snapshot.signalTimestamp == intent.timestamp, \"UPV: Snapshot timestamp mismatch\");\n        require(snapshot.timestampBuffer <= MAX_TIMESTAMP_BUFFER, \"UPV: Snapshot timestamp buffer exceeds maximum\");\n\n        IEscrow.DepositPaymentMethodData memory paymentMethodData = IEscrow(intent.escrow)\n            .getDepositPaymentMethodData(intent.depositId, snapshot.paymentMethod);\n        require(snapshot.payeeDetails == paymentMethodData.payeeDetails, \"UPV: Snapshot payee mismatch\");\n    }\n\n    /**\n     * Nullifies a payment to prevent double-spending\n     * @dev Creates a unique nullifier by encoding both the payment method and payment ID together.\n     * This prevents collisions where the same payment ID could exist across different payment\n     * methods (e.g., Venmo transaction #123 vs PayPal transaction #123).\n     */\n    function _nullifyPayment(bytes32 paymentMethod, bytes32 paymentId) internal {\n        bytes32 nullifier = keccak256(abi.encodePacked(paymentMethod, paymentId));\n        _validateAndAddNullifier(nullifier);\n    }\n\n    /**\n     * Calculates the release amount for an intent by capping the release amount to the intent amount\n     */\n    function _calculateReleaseAmount(uint256 releaseAmount, uint256 intentAmount) internal pure returns (uint256) {\n        if (releaseAmount > intentAmount) {\n            return intentAmount;\n        }\n        return releaseAmount;\n    }\n\n    /**\n     * Emits the payment details for offchain reconciliation\n     */\n    function _emitPaymentDetails(bytes32 intentHash, PaymentDetails memory paymentDetails) internal {\n        emit PaymentVerified(\n            intentHash,                 // Tie the payment details to the intent hash\n            paymentDetails.method,\n            paymentDetails.currency,\n            paymentDetails.amount,\n            paymentDetails.timestamp,\n            paymentDetails.paymentId,\n            paymentDetails.payeeId\n        );\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}