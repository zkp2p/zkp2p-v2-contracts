import 'ts-node/register/transpile-only';
import * as fs from 'fs';
import * as path from 'path';

const ROOT = path.resolve(__dirname, '../../../../');
const TYPECHAIN_SRC = path.join(ROOT, 'typechain');
const PKG_ROOT = path.resolve(__dirname, '../..');
const TYPECHAIN_DEST = path.join(PKG_ROOT, 'types');

function ensureDir(dir: string) {
  if (!fs.existsSync(dir)) fs.mkdirSync(dir, { recursive: true });
}

function shouldExclude(filePath: string): boolean {
  const basename = path.basename(filePath);
  const lowercaseBasename = basename.toLowerCase();

  // Exclude mocks directory and any files/directories with "mock" in the name
  if (lowercaseBasename.includes('mock')) {
    return true;
  }

  // Also exclude factories directory since we don't want to export factories
  if (basename === 'factories') {
    return true;
  }

  return false;
}

function copyRecursive(src: string, dest: string) {
  // Skip if this path should be excluded
  if (shouldExclude(src)) {
    return;
  }

  const stats = fs.statSync(src);
  if (stats.isDirectory()) {
    ensureDir(dest);
    for (const entry of fs.readdirSync(src)) {
      copyRecursive(path.join(src, entry), path.join(dest, entry));
    }
  } else {
    fs.copyFileSync(src, dest);
  }
}

function writeCuratedIndex(destRoot: string) {
  const content = `/* Autogenerated by extractor. Curated types only (no OpenZeppelin, no mocks, no factories). */
/* tslint:disable */
/* eslint-disable */
export * as contracts from './contracts';
`;
  fs.writeFileSync(path.join(destRoot, 'index.ts'), content, 'utf8');
}

export async function extractTypes(): Promise<void> {
  if (!fs.existsSync(TYPECHAIN_SRC)) {
    console.warn('⚠️  No root typechain directory found. Run `yarn typechain` first.');
    return;
  }
  // Clean destination if it exists to avoid stale OZ files
  if (fs.existsSync(TYPECHAIN_DEST)) {
    fs.rmSync(TYPECHAIN_DEST, { recursive: true, force: true });
  }
  ensureDir(TYPECHAIN_DEST);

  // Copy only curated pieces: common.ts, contracts (exclude factories and any OZ)
  const commonSrc = path.join(TYPECHAIN_SRC, 'common.ts');
  if (fs.existsSync(commonSrc)) {
    fs.copyFileSync(commonSrc, path.join(TYPECHAIN_DEST, 'common.ts'));
  }

  const contractsSrc = path.join(TYPECHAIN_SRC, 'contracts');
  if (fs.existsSync(contractsSrc)) {
    copyRecursive(contractsSrc, path.join(TYPECHAIN_DEST, 'contracts'));
    
    // Clean up the contracts/index.ts to remove mock references
    const contractsIndexPath = path.join(TYPECHAIN_DEST, 'contracts', 'index.ts');
    if (fs.existsSync(contractsIndexPath)) {
      let indexContent = fs.readFileSync(contractsIndexPath, 'utf8');
      // Remove all lines containing mock imports or exports
      const lines = indexContent.split('\n');
      const filteredLines = lines.filter(line => {
        const trimmedLine = line.trim().toLowerCase();
        // Remove any line that imports or exports mocks
        if (trimmedLine.includes('mock')) {
          return false;
        }
        return true;
      });
      indexContent = filteredLines.join('\n');
      fs.writeFileSync(contractsIndexPath, indexContent, 'utf8');
      console.log('✅ Cleaned mock imports from types/contracts/index.ts');
    }
  }

  // Write curated index that avoids re-exporting OpenZeppelin
  writeCuratedIndex(TYPECHAIN_DEST);

  console.log(`✅ Curated TypeChain types (excluding mocks, factories, OZ) copied to ${TYPECHAIN_DEST}`);
}
