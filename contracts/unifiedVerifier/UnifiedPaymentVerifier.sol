// SPDX-License-Identifier: MIT
pragma solidity ^0.8.18;

import { BaseUnifiedPaymentVerifier } from "./BaseUnifiedPaymentVerifier.sol";
import { INullifierRegistry } from "../interfaces/INullifierRegistry.sol";
import { IPaymentVerifier } from "../interfaces/IPaymentVerifier.sol";
import { IAttestationVerifier } from "./interfaces/IAttestationVerifier.sol";
/**
 * @title UnifiedPaymentVerifier
 * @notice Verifies payment proofs from multiple payment methods using witness attestations
 */
contract UnifiedPaymentVerifier is IPaymentVerifier, BaseUnifiedPaymentVerifier {
    
    /* ============ Constants ============ */
    
    // EIP-712 Domain Separator
    bytes32 private constant DOMAIN_TYPEHASH = keccak256(
        "EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)"
    );
    
    // EIP-712 Type Hash for PaymentDetails
    bytes32 private constant PAYMENT_DETAILS_TYPEHASH = keccak256(
        "PaymentDetails(bytes32 processorProviderHash,string paymentMethod,uint256 intentHash,bytes32 receiverId,uint256 amount,uint256 timestamp,string paymentId,string currency,bytes32 dataHash)"
    );
    
    /* ============ State Variables ============ */
    
    // EIP-712 Domain Separator (computed once at deployment)
    bytes32 public immutable DOMAIN_SEPARATOR;
    
    /* ============ Structs ============ */
    
    // Struct to hold the standardized payment details extracted from the proof
    struct PaymentDetails {
        // Payment proof details
        bytes32 processorProviderHash;   // Unique identifier binding processor to provider (TODO: UNDERSTAND THIS)
        bytes[] signatures;              // Array of signatures from witnesses
        string paymentMethod;            // Payment method (e.g., "venmo", "paypal", "wise")
        uint256 intentHash;              // Intent hash from the protocol
        // Payment details
        bytes32 receiverId;              // Payment receiver ID
        uint256 amount;                  // Payment amount in smallest currency unit (i.e. cents)
        uint256 timestamp;               // Payment timestamp in UTC in milliseconds
        string paymentId;                // Unique payment identifier from the service
        string currency;                 // Currency (e.g., "USD", "EUR")
        bytes32 dataHash;                // Hash of verification data for integrity
    }

    /* ============ Constructor ============ */
    
    /**
     * Initializes the unified payment verifier
     * @param _escrow The escrow contract address
     * @param _nullifierRegistry The nullifier registry contract
     * @param _attestationVerifier The attestation verifier contract
     */
    constructor(
        address _escrow,
        INullifierRegistry _nullifierRegistry,
        IAttestationVerifier _attestationVerifier
    ) BaseUnifiedPaymentVerifier(
        _escrow,
        _nullifierRegistry,
        _attestationVerifier
    ) {
        // Compute EIP-712 domain separator
        DOMAIN_SEPARATOR = keccak256(
            abi.encode(
                DOMAIN_TYPEHASH,
                keccak256(bytes("UnifiedPaymentVerifier")), // name
                keccak256(bytes("1")),                      // version
                block.chainid,                              // chainId
                address(this)                               // verifyingContract
            )
        );
    }

    /* ============ External Functions ============ */
    
    /**
     * ONLY RAMP: Verifies a standardized payment proof generated by the attestation service.
     * 
     * @param _verifyPaymentData Payment proof and intent details required for verification
     * @return result The payment verification result containing success status, intent hash, release amount, payment currency
     * and payment ID
     */
    function verifyPayment(
        VerifyPaymentData calldata _verifyPaymentData
    )
        external
        override
        onlyOrchestrator()
        returns (PaymentVerificationResult memory result)
    {
        PaymentDetails memory paymentDetails = abi.decode(
            _verifyPaymentData.paymentProof, 
            (PaymentDetails)
        );
        
        PaymentMethodStore storage store = _getPaymentMethodStore(
            paymentDetails.paymentMethod
        );
        
        // Verify the attestation
        bool isValid = _verifyAttestation(paymentDetails, _verifyPaymentData);
        require(isValid, "UnifiedPaymentVerifier: Invalid witness signatures");

        // Verify the processor hash is authorized for this payment method
        require(
            store.isProviderHash[paymentDetails.processorProviderHash],
            "UnifiedPaymentVerifier: Unauthorized processor for payment method"
        );
        
        _verifyPaymentDetails(paymentDetails, store, _verifyPaymentData);

        // Nullify the payment to prevent double-spending
        // TODO: ADDRESS SCROLL AUDIT CONCERNS
        bytes32 nullifier = keccak256(abi.encodePacked(paymentDetails.paymentId));
        _validateAndAddNullifier(nullifier);

        // Calculate the release amount
        uint256 releaseAmount = _calculateReleaseAmount(
            paymentDetails.amount, 
            _verifyPaymentData.conversionRate, 
            _verifyPaymentData.intentAmount
        );
        
        // Build the verification result
        result = PaymentVerificationResult({
            success: true,
            // todo: decide if we wanna coninue enforcing the intent hash
            intentHash: bytes32(paymentDetails.intentHash),
            releaseAmount: releaseAmount,
            paymentCurrency: keccak256(abi.encodePacked(paymentDetails.currency)),
            paymentId: paymentDetails.paymentId
        });
        
        return result;
    }

    /* ============ Internal Functions ============ */

    /**
     * Verifies the EIP-712 attestation using the attestation verifier. Also verifies the integrity of the 
     * verify payment data using the data hash attached to the attestation.
     */
    function _verifyAttestation(
        PaymentDetails memory paymentDetails,
        VerifyPaymentData calldata _verifyPaymentData
    ) internal view returns (bool) {
        // Create EIP-712 struct hash for the payment details
        bytes32 structHash = keccak256(
            abi.encode(
                PAYMENT_DETAILS_TYPEHASH,
                paymentDetails.processorProviderHash,
                keccak256(bytes(paymentDetails.paymentMethod)),    // Hash string fields
                paymentDetails.intentHash,
                paymentDetails.receiverId,
                paymentDetails.amount,
                paymentDetails.timestamp,
                keccak256(bytes(paymentDetails.paymentId)),        // Hash string fields
                keccak256(bytes(paymentDetails.currency)),         // Hash string fields
                paymentDetails.dataHash                            // Include dataHash in struct
            )
        );
        
        // Create EIP-712 digest
        bytes32 digest = keccak256(
            abi.encodePacked(
                "\x19\x01",
                DOMAIN_SEPARATOR,
                structHash
            )
        );

        // Verify data integrity - the data hash must match what was signed
        require(
            keccak256(_verifyPaymentData.data) == paymentDetails.dataHash,
            "UnifiedPaymentVerifier: Data hash mismatch"
        );

        // Call the attestation verifier with verified data
        bool isValid = attestationVerifier.verify(
            digest, 
            paymentDetails.signatures,
            _verifyPaymentData.data  // Use data field instead of depositData
        );

        return isValid;
    }

    /**
     * Verifies the payment details. Verifies the payee, currency and timestamp against the verify payment data.
     */
    function _verifyPaymentDetails(
        PaymentDetails memory paymentDetails,
        PaymentMethodStore storage config,
        VerifyPaymentData calldata _verifyPaymentData
    ) internal view {
        // Verify the payee matches what's expected
        bytes32 expectedPayeeHash = keccak256(abi.encodePacked(_verifyPaymentData.payeeDetails));
        require(
            paymentDetails.receiverId == expectedPayeeHash,
            "UnifiedPaymentVerifier: Payee mismatch"
        );
        
        // Verify the currency matches and is supported for this payment method
        bytes32 currencyHash = keccak256(abi.encodePacked(paymentDetails.currency));
        require(
            currencyHash == _verifyPaymentData.fiatCurrency,
            "UnifiedPaymentVerifier: Currency mismatch"
        );
        
        // Verify timestamp is after intent creation (with payment method-specific buffer for L2 flexibility)
        uint256 paymentTimestampWithBuffer = paymentDetails.timestamp + config.timestampBuffer;
        require(
            paymentTimestampWithBuffer >= _verifyPaymentData.intentTimestamp,
            "UnifiedPaymentVerifier: Payment before intent"
        );
    }
}