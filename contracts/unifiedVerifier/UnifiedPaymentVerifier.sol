// SPDX-License-Identifier: MIT
pragma solidity ^0.8.18;

import { BaseUnifiedPaymentVerifier } from "./BaseUnifiedPaymentVerifier.sol";
import { INullifierRegistry } from "../interfaces/INullifierRegistry.sol";
import { IPaymentVerifier } from "../interfaces/IPaymentVerifier.sol";

contract UnifiedPaymentVerifier is IPaymentVerifier, BaseUnifiedPaymentVerifier {
    
    /* ============ Structs ============ */
    
    // Struct to hold the standardized payment details extracted from the proof
    struct PaymentDetails {
        // Payment proof details
        bytes32 processorProviderHash;   // Unique identifier binding processor to provider (TODO: UNDERSTAND THIS)
        bytes[] signatures;              // Array of signatures from witnesses
        string paymentMethod;            // Payment method (e.g., "venmo", "paypal", "wise")
        uint256 intentHash;              // Intent hash from the protocol
        // Payment details
        bytes32 receiverId;              // Payment receiver ID
        uint256 amount;                  // Payment amount in smallest currency unit (i.e. cents)
        uint256 timestamp;               // Payment timestamp in UTC in milliseconds
        string paymentId;                // Unique payment identifier from the service
        string currency;                 // Currency (e.g., "USD", "EUR")
    }

    /* ============ Constructor ============ */
    
    /**
     * Initializes the unified payment verifier
     * @param _escrow The escrow contract address
     * @param _nullifierRegistry The nullifier registry contract
     * @param _minWitnessSignatures Minimum number of witness signatures required
     */
    constructor(
        address _escrow,
        INullifierRegistry _nullifierRegistry,
        uint256 _minWitnessSignatures
    ) BaseUnifiedPaymentVerifier(
        _escrow,
        _nullifierRegistry,
        _minWitnessSignatures
    ) {}

    /* ============ External Functions ============ */
    
    /**
     * ONLY RAMP: Verifies a standardized payment proof generated by a notary.
     * 
     * @param _verifyPaymentData Payment proof and intent details required for verification
     * @return result The payment verification result containing success status, intent hash, release amount, payment currency and payment ID
     */
    function verifyPayment(
        VerifyPaymentData calldata _verifyPaymentData
    )
        external
        override
        onlyEscrow
        returns (PaymentVerificationResult memory result)
    {
        // Decode the generic payment details data from the proof bytes
        PaymentDetails memory paymentDetails = abi.decode(_verifyPaymentData.paymentProof, (PaymentDetails));
        
        // Hash the payment method name
        bytes32 paymentMethodHash = keccak256(abi.encodePacked(paymentDetails.paymentMethod));
        
        // Get payment method configuration
        PaymentMethodConfig storage config = paymentMethodConfig[paymentMethodHash];
        require(config.initialized, "UnifiedPaymentVerifier: Payment method does not exist");
        
        // Verify the processor hash is authorized for this payment method
        require(
            config.processorHashExists[paymentDetails.processorProviderHash],
            "UnifiedPaymentVerifier: Unauthorized processor for payment method"
        );
        
        // Decode witnesses from deposit data
        address[] memory witnesses = _decodeWitnesses(_verifyPaymentData.depositData);
        
        // Reconstruct the message that was signed by the attestor
        // The attestor signs: keccak256(abi.encode(processorHash, paymentMethod, intentHash, receiverId, amount, timestamp, paymentId, currency))
        bytes memory encoded = abi.encode(
            paymentDetails.processorProviderHash,
            paymentDetails.paymentMethod,
            paymentDetails.intentHash,
            paymentDetails.receiverId,
            paymentDetails.amount,
            paymentDetails.timestamp,
            paymentDetails.paymentId,
            paymentDetails.currency
        );
        bytes32 messageHash = keccak256(encoded);
        
        // Verify witness signatures meet threshold
        require(
            _verifyWitnessSignatures(messageHash, paymentDetails.signatures, witnesses),
            "UnifiedPaymentVerifier: Invalid witness signatures"
        );
        
        // Verify the payee matches what's expected
        bytes32 expectedPayeeHash = keccak256(abi.encodePacked(_verifyPaymentData.payeeDetails));
        require(
            paymentDetails.receiverId == expectedPayeeHash,
            "UnifiedPaymentVerifier: Payee mismatch"
        );
        
        // Verify the currency matches and is supported for this payment method
        bytes32 currencyHash = keccak256(abi.encodePacked(paymentDetails.currency));
        require(
            currencyHash == _verifyPaymentData.fiatCurrency,
            "UnifiedPaymentVerifier: Currency mismatch"
        );
        require(
            config.currencyExists[currencyHash],
            "UnifiedPaymentVerifier: Currency not supported for payment method"
        );
        
        // Verify timestamp is after intent creation (with payment method-specific buffer for L2 flexibility)
        uint256 paymentTimestampWithBuffer = paymentDetails.timestamp + config.timestampBuffer;
        require(
            paymentTimestampWithBuffer >= _verifyPaymentData.intentTimestamp,
            "UnifiedPaymentVerifier: Payment before intent"
        );
        
        // Calculate release amount based on conversion rate
        // amount * 1e18 / conversionRate = release amount in tokens
        uint256 releaseAmount = (paymentDetails.amount * 1e18) / _verifyPaymentData.conversionRate;
        
        // Ensure release amount doesn't exceed intent amount
        // TODO: INSTEAD JUST CAP THE RELEASE AMOUNT TO THE INTENT AMOUNT
        require(
            releaseAmount <= _verifyPaymentData.intentAmount,
            "UnifiedPaymentVerifier: Release amount exceeds intent"
        );
        
        // Nullify the payment to prevent double-spending
        // TODO: ADDRESS SCROLL AUDIT CONCERNS
        bytes32 nullifier = keccak256(abi.encodePacked(paymentDetails.paymentId));
        _validateAndAddNullifier(nullifier);
        
        // Build the verification result
        result = PaymentVerificationResult({
            success: true,
            intentHash: bytes32(paymentDetails.intentHash),
            releaseAmount: releaseAmount,
            paymentCurrency: currencyHash,
            paymentId: paymentDetails.paymentId
        });
        
        return result;
    }
}