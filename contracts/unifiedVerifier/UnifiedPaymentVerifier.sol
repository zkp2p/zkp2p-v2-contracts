// SPDX-License-Identifier: MIT
pragma solidity ^0.8.18;

import { BaseUnifiedPaymentVerifier } from "./BaseUnifiedPaymentVerifier.sol";
import { INullifierRegistry } from "../interfaces/INullifierRegistry.sol";
import { IPaymentVerifier } from "../interfaces/IPaymentVerifier.sol";
import { IAttestationVerifier } from "../interfaces/IAttestationVerifier.sol";

/**
 * @title UnifiedPaymentVerifier
 * @notice Verifies payment proofs for multiple payment methods. This is a unified verifier that 
 * replaces individual payment verifiers (VenmoVerifier, PayPalVerifier, etc.) with a single 
 * configurable contract.
 * 
 * Key features:
 * - Supports multiple payment methods, each with custom configuration
 * - Uses AttestationVerifier to validate off-chain zkTLS proofs and transformations
 * - Ensures trust anchor integrity for off-chain verification processes
 * - Verifies standardized payment details against provided data
 * @dev The payment attestation should be signed using the EIP-712 standard
 */
contract UnifiedPaymentVerifier is IPaymentVerifier, BaseUnifiedPaymentVerifier {

    /* ============ Constants ============ */
    
    // EIP-712 Domain Separator
    bytes32 private constant DOMAIN_TYPEHASH = keccak256(
        "EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)"
    );
    
    // EIP-712 Type Hash for PaymentAttestation
    bytes32 private constant PAYMENT_ATTESTATION_TYPEHASH = keccak256(
        "PaymentAttestation(bytes32 paymentMethod,bytes32 providerHash,bytes32 intentHash,bytes32 recipientId,uint256 amount,uint256 timestamp,bytes32 paymentId,bytes32 currency,bytes32 dataHash)"
    );
    
    /* ============ State Variables ============ */
    
    // EIP-712 Domain Separator (computed once at deployment)
    bytes32 public immutable DOMAIN_SEPARATOR;
    
    /* ============ Structs ============ */

    struct PaymentDetails {
        bytes32 recipientId;             // Payment recipient ID (hashed payee details to preserve privacy)
        uint256 amount;                  // Payment amount in smallest currency unit (i.e. cents)
        uint256 timestamp;               // Payment timestamp in UTC in milliseconds
        bytes32 paymentId;               // Hashed payment identifier from the service (e.g. hashed venmo payment ID)
        bytes32 currency;                // Currency hash (e.g., "USD", "EUR")
    }

    struct PaymentAttestation {
        bytes32 paymentMethod;           // Payment method hash (e.g., "venmo", "paypal", "wise")
        bytes32 providerHash;            // Unique identifier binding processor to provider
        bytes32 intentHash;              // Binds the payment to the intent on Orchestrator
        PaymentDetails paymentDetails;   // Payment details
        bytes[] signatures;              // Array of signatures from witnesses
        bytes32 dataHash;                // Hash of verification data for integrity
    }

    /* ============ Constructor ============ */
    
    constructor(
        address _escrow,
        INullifierRegistry _nullifierRegistry,
        IAttestationVerifier _attestationVerifier
    ) BaseUnifiedPaymentVerifier(
        _escrow,
        _nullifierRegistry,
        _attestationVerifier
    ) {
        // Compute EIP-712 domain separator
        DOMAIN_SEPARATOR = keccak256(
            abi.encode(
                DOMAIN_TYPEHASH,
                keccak256(bytes("UnifiedPaymentVerifier")), // name
                keccak256(bytes("1")),                      // version
                block.chainid,                              // chainId
                address(this)                               // verifyingContract
            )
        );
    }

    /* ============ External Functions ============ */
    
    /**
     * ONLY ORCHESTRATOR: Verifies a standardized payment attestation generated by the attestation service.
     * 
     * @param _verifyPaymentData Payment proof and intent details required for verification
     * @return result The payment verification result containing success status, intent hash, release amount, 
     * and the attested payment currency
     */
    function verifyPayment(
        VerifyPaymentData calldata _verifyPaymentData
    )
        external
        override
        onlyOrchestrator()
        returns (PaymentVerificationResult memory result)
    {
        PaymentAttestation memory attestation = abi.decode(
            _verifyPaymentData.paymentProof, 
            (PaymentAttestation)
        );
        
        PaymentMethodStore storage store = _getPaymentMethodStore(
            attestation.paymentMethod
        );
        
        // Verify the attestation
        bool isValid = _verifyAttestation(attestation, _verifyPaymentData);
        require(isValid, "UPV: Invalid witness signatures");
        
        PaymentDetails memory paymentDetails = attestation.paymentDetails;
        _verifyPaymentDetails(paymentDetails, store, _verifyPaymentData);

        // Nullify the payment to prevent double-spending
        _nullifyPayment(attestation.paymentMethod, paymentDetails.paymentId);

        result = _createPaymentVerificationResult(
            _verifyPaymentData,
            attestation,
            paymentDetails
        );
        
        return result;
    }

    /* ============ Internal Functions ============ */

    /**
     * Verifies the EIP-712 attestation using the attestation verifier. Also verifies the integrity of the 
     * verify payment data using the data hash attached to the attestation.
     */
    function _verifyAttestation(
        PaymentAttestation memory attestation,
        VerifyPaymentData calldata _verifyPaymentData
    ) internal view returns (bool) {
        bytes32 structHash = keccak256(
            abi.encode(
                PAYMENT_ATTESTATION_TYPEHASH,
                attestation.paymentMethod,
                attestation.providerHash,
                attestation.intentHash,
                attestation.paymentDetails.recipientId,
                attestation.paymentDetails.amount,
                attestation.paymentDetails.timestamp,
                attestation.paymentDetails.paymentId,
                attestation.paymentDetails.currency,
                attestation.dataHash
            )
        );
        
        bytes32 digest = keccak256(
            abi.encodePacked(
                "\x19\x01",
                DOMAIN_SEPARATOR,
                structHash
            )
        );

        // Verify data integrity - the data hash must match what was signed
        require(
            keccak256(_verifyPaymentData.data) == attestation.dataHash,
            "UPV: Data hash mismatch"
        );

        bool isValid = attestationVerifier.verify(
            digest, 
            attestation.signatures,
            _verifyPaymentData.data
        );

        return isValid;
    }

    /**
     * Verifies the payment details. Verifies the receiver ID (payee), currency and timestamp against the verify payment data.
     */
    function _verifyPaymentDetails(
        PaymentDetails memory paymentDetails,
        PaymentMethodStore storage config,
        VerifyPaymentData calldata _verifyPaymentData
    ) internal view {
        require(
            paymentDetails.recipientId == _verifyPaymentData.payeeDetails,
            "UPV: Payee mismatch"
        );
        
        // Verify timestamp is after intent creation (with payment method-specific buffer for L2 flexibility)
        uint256 paymentTimestampWithBuffer = paymentDetails.timestamp + config.timestampBuffer;
        require(
            paymentTimestampWithBuffer >= _verifyPaymentData.intentTimestamp,
            "UPV: Payment before intent"
        );
    }

    /**
     * Nullifies a payment to prevent double-spending
     * @dev Creates a unique nullifier by encoding both the payment method and payment ID together.
     * This prevents collisions where the same payment ID could exist across different payment
     * methods (e.g., Venmo transaction #123 vs PayPal transaction #123).
     */
    function _nullifyPayment(bytes32 paymentMethod, bytes32 paymentId) internal {
        bytes32 nullifier = keccak256(abi.encodePacked(paymentMethod, paymentId));
        _validateAndAddNullifier(nullifier);
    }

    /**
     * Creates the release amount and creates the payment verification result to return to the Orchestrator.
     */
    function _createPaymentVerificationResult(
        VerifyPaymentData calldata _verifyPaymentData,
        PaymentAttestation memory attestation,
        PaymentDetails memory paymentDetails
    ) internal pure returns (PaymentVerificationResult memory result) {
        uint256 releaseAmount = _calculateReleaseAmount(
            paymentDetails.amount, 
            _verifyPaymentData.conversionRate, 
            _verifyPaymentData.intentAmount
        );
        
        result = PaymentVerificationResult({
            success: true,
            intentHash: attestation.intentHash,
            releaseAmount: releaseAmount,
            paymentCurrency: paymentDetails.currency
        });
    }
}
