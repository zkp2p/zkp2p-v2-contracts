// SPDX-License-Identifier: MIT
pragma solidity ^0.8.18;

import { BaseUnifiedPaymentVerifier } from "./BaseUnifiedPaymentVerifier.sol";
import { INullifierRegistry } from "../interfaces/INullifierRegistry.sol";
import { IPaymentVerifier } from "../interfaces/IPaymentVerifier.sol";
import { IAttestationVerifier } from "./IAttestationVerifier.sol";

/**
 * @title UnifiedPaymentVerifier
 * @notice Verifies payment proofs from multiple payment methods using witness attestations
 */
contract UnifiedPaymentVerifier is IPaymentVerifier, BaseUnifiedPaymentVerifier {
    
    /* ============ Constants ============ */
    
    // EIP-712 Domain Separator
    bytes32 private constant DOMAIN_TYPEHASH = keccak256(
        "EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)"
    );
    
    // EIP-712 Type Hash for PaymentDetails
    bytes32 private constant PAYMENT_DETAILS_TYPEHASH = keccak256(
        "PaymentDetails(bytes32 processorProviderHash,string paymentMethod,uint256 intentHash,bytes32 receiverId,uint256 amount,uint256 timestamp,string paymentId,string currency,bytes32 dataHash)"
    );
    
    /* ============ State Variables ============ */
    
    // EIP-712 Domain Separator (computed once at deployment)
    bytes32 public immutable DOMAIN_SEPARATOR;
    
    /* ============ Structs ============ */
    
    // Struct to hold the standardized payment details extracted from the proof
    struct PaymentDetails {
        // Payment proof details
        bytes32 processorProviderHash;   // Unique identifier binding processor to provider (TODO: UNDERSTAND THIS)
        bytes[] signatures;              // Array of signatures from witnesses
        string paymentMethod;            // Payment method (e.g., "venmo", "paypal", "wise")
        uint256 intentHash;              // Intent hash from the protocol
        // Payment details
        bytes32 receiverId;              // Payment receiver ID
        uint256 amount;                  // Payment amount in smallest currency unit (i.e. cents)
        uint256 timestamp;               // Payment timestamp in UTC in milliseconds
        string paymentId;                // Unique payment identifier from the service
        string currency;                 // Currency (e.g., "USD", "EUR")
        bytes32 dataHash;                // Hash of verification data for integrity
    }

    /* ============ Constructor ============ */
    
    /**
     * Initializes the unified payment verifier
     * @param _escrow The escrow contract address
     * @param _nullifierRegistry The nullifier registry contract
     * @param _attestationVerifier The attestation verifier contract
     */
    constructor(
        address _escrow,
        INullifierRegistry _nullifierRegistry,
        IAttestationVerifier _attestationVerifier
    ) BaseUnifiedPaymentVerifier(
        _escrow,
        _nullifierRegistry,
        _attestationVerifier
    ) {
        // Compute EIP-712 domain separator
        DOMAIN_SEPARATOR = keccak256(
            abi.encode(
                DOMAIN_TYPEHASH,
                keccak256(bytes("UnifiedPaymentVerifier")), // name
                keccak256(bytes("1")),                      // version
                block.chainid,                              // chainId
                address(this)                               // verifyingContract
            )
        );
    }

    /* ============ External Functions ============ */
    
    /**
     * ONLY RAMP: Verifies a standardized payment proof generated by a notary.
     * 
     * @param _verifyPaymentData Payment proof and intent details required for verification
     * @return result The payment verification result containing success status, intent hash, release amount, payment currency and payment ID
     */
    function verifyPayment(
        VerifyPaymentData calldata _verifyPaymentData
    )
        external
        override
        onlyEscrow
        returns (PaymentVerificationResult memory result)
    {
        // Decode the generic payment details data from the proof bytes
        PaymentDetails memory paymentDetails = abi.decode(_verifyPaymentData.paymentProof, (PaymentDetails));
        
        // Hash the payment method name
        bytes32 paymentMethodHash = keccak256(abi.encodePacked(paymentDetails.paymentMethod));
        
        // Get payment method configuration
        PaymentMethodConfig storage config = paymentMethodConfig[paymentMethodHash];
        require(config.initialized, "UnifiedPaymentVerifier: Payment method does not exist");
        
        // Verify the processor hash is authorized for this payment method
        require(
            config.processorHashExists[paymentDetails.processorProviderHash],
            "UnifiedPaymentVerifier: Unauthorized processor for payment method"
        );
        
        // CRITICAL: Verify data integrity - the data hash must match what was signed
        require(
            keccak256(_verifyPaymentData.data) == paymentDetails.dataHash,
            "UnifiedPaymentVerifier: Data hash mismatch"
        );
        
        // Create EIP-712 struct hash for the payment details
        bytes32 structHash = keccak256(
            abi.encode(
                PAYMENT_DETAILS_TYPEHASH,
                paymentDetails.processorProviderHash,
                keccak256(bytes(paymentDetails.paymentMethod)),    // Hash string fields
                paymentDetails.intentHash,
                paymentDetails.receiverId,
                paymentDetails.amount,
                paymentDetails.timestamp,
                keccak256(bytes(paymentDetails.paymentId)),        // Hash string fields
                keccak256(bytes(paymentDetails.currency)),         // Hash string fields
                paymentDetails.dataHash                            // Include dataHash in struct
            )
        );
        
        // Create EIP-712 digest
        bytes32 digest = keccak256(
            abi.encodePacked(
                "\x19\x01",
                DOMAIN_SEPARATOR,
                structHash
            )
        );

        // Call the attestation verifier with verified data
        bool isValid = attestationVerifier.verify(
            digest, 
            paymentDetails.signatures,
            _verifyPaymentData.data  // Use data field instead of depositData
        );
        
        // Require valid signatures
        require(isValid, "UnifiedPaymentVerifier: Invalid witness signatures");
        
        // Verify the payee matches what's expected
        bytes32 expectedPayeeHash = keccak256(abi.encodePacked(_verifyPaymentData.payeeDetails));
        require(
            paymentDetails.receiverId == expectedPayeeHash,
            "UnifiedPaymentVerifier: Payee mismatch"
        );
        
        // Verify the currency matches and is supported for this payment method
        bytes32 currencyHash = keccak256(abi.encodePacked(paymentDetails.currency));
        require(
            currencyHash == _verifyPaymentData.fiatCurrency,
            "UnifiedPaymentVerifier: Currency mismatch"
        );
        require(
            config.currencyExists[currencyHash],
            "UnifiedPaymentVerifier: Currency not supported for payment method"
        );
        
        // Verify timestamp is after intent creation (with payment method-specific buffer for L2 flexibility)
        uint256 paymentTimestampWithBuffer = paymentDetails.timestamp + config.timestampBuffer;
        require(
            paymentTimestampWithBuffer >= _verifyPaymentData.intentTimestamp,
            "UnifiedPaymentVerifier: Payment before intent"
        );
        
        // Calculate release amount based on conversion rate
        // amount * 1e18 / conversionRate = release amount in tokens
        uint256 releaseAmount = (paymentDetails.amount * 1e18) / _verifyPaymentData.conversionRate;
        
        // Ensure release amount doesn't exceed intent amount
        // TODO: INSTEAD JUST CAP THE RELEASE AMOUNT TO THE INTENT AMOUNT
        require(
            releaseAmount <= _verifyPaymentData.intentAmount,
            "UnifiedPaymentVerifier: Release amount exceeds intent"
        );
        
        // Nullify the payment to prevent double-spending
        // TODO: ADDRESS SCROLL AUDIT CONCERNS
        bytes32 nullifier = keccak256(abi.encodePacked(paymentDetails.paymentId));
        _validateAndAddNullifier(nullifier);
        
        // Build the verification result
        result = PaymentVerificationResult({
            success: true,
            intentHash: bytes32(paymentDetails.intentHash),
            releaseAmount: releaseAmount,
            paymentCurrency: currencyHash,
            paymentId: paymentDetails.paymentId
        });
        
        return result;
    }
}