// SPDX-License-Identifier: MIT
pragma solidity ^0.8.18;

import { BaseUnifiedPaymentVerifier } from "./BaseUnifiedPaymentVerifier.sol";
import { INullifierRegistry } from "../interfaces/INullifierRegistry.sol";
import { IPaymentVerifier } from "../interfaces/IPaymentVerifier.sol";
import { IAttestationVerifier } from "../interfaces/IAttestationVerifier.sol";
import { IOrchestrator } from "../interfaces/IOrchestrator.sol";
import { IEscrow } from "../interfaces/IEscrow.sol";

/**
 * @title UnifiedPaymentVerifier
 * @notice Verifies payment proofs for multiple payment methods. This is a unified verifier that 
 * replaces individual payment verifiers (VenmoVerifier, PayPalVerifier, etc.) with a single 
 * configurable contract.
 * 
 * Key features:
 * - Supports multiple payment methods, each with custom configuration
 * - Uses AttestationVerifier to validate offchain payment attestations   
 * - Ensures trust anchor integrity for off-chain verification processes
 * - Verifies standardized payment details against provided data
 * @dev The payment attestation should be signed using the EIP-712 standard
 */
contract UnifiedPaymentVerifier is IPaymentVerifier, BaseUnifiedPaymentVerifier {

    /* ============ Constants ============ */
    
    // Max timestamp buffer
    uint256 private constant MAX_TIMESTAMP_BUFFER = 24 * 60 * 60 * 1000; // 24 hours

    // EIP-712 Domain Separator
    bytes32 private constant DOMAIN_TYPEHASH = keccak256(
        "EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)"
    );
    
    // EIP-712 Type Hash for PaymentAttestation
    bytes32 private constant PAYMENT_ATTESTATION_TYPEHASH = keccak256(
        "PaymentAttestation(bytes32 intentHash,uint256 releaseAmount,bytes32 dataHash)"
    );

    /* ============ State Variables ============ */

    // EIP-712 Domain Separator (computed once at deployment)
    bytes32 public immutable DOMAIN_SEPARATOR;

    /* ============ Events ============ */

    /**
     * @notice Capture and emit payment details for offchain reconciliation
     */
    event PaymentVerified(
        bytes32 indexed intentHash,
        bytes32 indexed method,
        bytes32 indexed currency,
        uint256 amount,
        uint256 timestamp,
        bytes32 paymentId,
        bytes32 payeeId
    );

    /* ============ Structs ============ */

    struct PaymentDetails {
        bytes32 method;           // Payment method hash (e.g., "venmo", "paypal", "wise")
        bytes32 payeeId;          // Payment recipient ID (hashed payee details to preserve privacy)
        uint256 amount;           // Payment amount in smallest currency unit (i.e. cents)
        bytes32 currency;         // Payment currency hash (e.g., "USD", "EUR")
        uint256 timestamp;        // Payment timestamp in UTC in milliseconds
        bytes32 paymentId;        // Hashed payment identifier from the service (e.g. hashed venmo payment ID to preserve privacy)
    }

    struct IntentSnapshot {
        bytes32 intentHash;
        uint256 amount;
        bytes32 paymentMethod;
        bytes32 fiatCurrency;
        bytes32 payeeDetails;
        uint256 conversionRate;
        uint256 signalTimestamp;
        uint256 timestampBuffer;
    }

    struct PaymentAttestation {
        bytes32 intentHash;       // Binds the payment to the intent on Orchestrator
        uint256 releaseAmount;    // Final token amount to release on-chain after FX
        bytes32 dataHash;         // Hash of the additional data to verify integrity
        bytes[] signatures;       // Array of signatures from witnesses
        bytes data;               // Data for verification
        bytes metadata;           // Additional metadata; isn't signed by the witnesses
    }

    /* ============ Constructor ============ */
    
    constructor(
        IOrchestrator _orchestrator,
        INullifierRegistry _nullifierRegistry,
        IAttestationVerifier _attestationVerifier
    ) BaseUnifiedPaymentVerifier(
        _orchestrator,
        _nullifierRegistry,
        _attestationVerifier
    ) {
        // Compute EIP-712 domain separator
        DOMAIN_SEPARATOR = keccak256(
            abi.encode(
                DOMAIN_TYPEHASH,
                keccak256(bytes("UnifiedPaymentVerifier")), // name
                keccak256(bytes("1")),                      // version
                block.chainid,                              // chainId
                address(this)                               // verifyingContract
            )
        );
    }

    /* ============ External Functions ============ */
    
    /**
     * ONLY ORCHESTRATOR: Verifies a standardized payment attestation generated by the attestation service.
     * 
     * @param _verifyPaymentData Payment proof and intent details required for verification
     * @return result The payment verification result containing success status, intent hash, and release amount
     * @dev Ensure the orchestrator verifies the intent exists before calling this function
     */
    function verifyPayment(
        VerifyPaymentData calldata _verifyPaymentData
    )
        external
        override
        onlyOrchestrator()
        returns (PaymentVerificationResult memory result)
    {
        PaymentAttestation memory attestation = _decodeAttestation(_verifyPaymentData.paymentProof);
        
        (
            PaymentDetails memory paymentDetails, 
            IntentSnapshot memory intentSnapshot
        ) = _decodeAttestationPayload(attestation.data);
        require(isPaymentMethod[paymentDetails.method], "UPV: Invalid payment method");
        
        _validateIntentSnapshot(_verifyPaymentData.intentHash, intentSnapshot);

        bool isValid = _verifyAttestation(attestation);
        require(isValid, "UPV: Invalid attestation");
                
        // Nullify the payment to prevent double-spending
        _nullifyPayment(paymentDetails.method, paymentDetails.paymentId);
        
        _emitPaymentDetails(attestation.intentHash, paymentDetails);
    
        uint256 releaseAmount = _calculateReleaseAmount(attestation.releaseAmount, intentSnapshot.amount);

        result = PaymentVerificationResult({
            success: true,
            intentHash: attestation.intentHash,
            releaseAmount: releaseAmount
        });

        return result;
    }

    /* ============ Internal Functions ============ */

    function _decodeAttestation(bytes memory paymentProof) internal pure returns (PaymentAttestation memory) {
        return abi.decode(paymentProof, (PaymentAttestation));
    }

    function _decodeAttestationPayload(bytes memory paymentData)
        internal
        pure
        returns (PaymentDetails memory paymentDetails, IntentSnapshot memory intentSnapshot)
    {
        (paymentDetails, intentSnapshot) = abi.decode(paymentData, (PaymentDetails, IntentSnapshot));
    }

    /**
     * Verifies the EIP-712 attestation using the attestation verifier. Also verifies the integrity of the 
     * verify payment data using the data hash attached to the attestation.
     */
    function _verifyAttestation(PaymentAttestation memory attestation) internal view returns (bool) {
        bytes32 structHash = keccak256(
            abi.encode(
                PAYMENT_ATTESTATION_TYPEHASH,
                attestation.intentHash,
                attestation.releaseAmount,
                attestation.dataHash
            )
        );
        
        bytes32 digest = keccak256(
            abi.encodePacked(
                "\x19\x01",
                DOMAIN_SEPARATOR,
                structHash
            )
        );

        // Verify data integrity - the data hash must match what was signed
        require(
            keccak256(attestation.data) == attestation.dataHash,
            "UPV: Data hash mismatch"
        );

        bool isValid = attestationVerifier.verify(
            digest, 
            attestation.signatures,
            attestation.data
        );

        return isValid;
    }

    function _validateIntentSnapshot(
        bytes32 intentHash,
        IntentSnapshot memory snapshot
    ) internal view {
        require(snapshot.intentHash == intentHash, "UPV: Snapshot hash mismatch");

        IOrchestrator.Intent memory intent = IOrchestrator(orchestrator).getIntent(intentHash);
        require(snapshot.amount == intent.amount, "UPV: Snapshot amount mismatch");
        require(snapshot.paymentMethod == intent.paymentMethod, "UPV: Snapshot method mismatch");
        require(snapshot.fiatCurrency == intent.fiatCurrency, "UPV: Snapshot currency mismatch");
        require(snapshot.conversionRate == intent.conversionRate, "UPV: Snapshot rate mismatch");
        require(snapshot.signalTimestamp == intent.timestamp, "UPV: Snapshot timestamp mismatch");
        require(snapshot.conversionRate == intent.conversionRate, "UPV: Snapshot conversion rate mismatch");
        require(snapshot.timestampBuffer <= MAX_TIMESTAMP_BUFFER, "UPV: Snapshot timestamp buffer exceeds maximum");

        IEscrow.DepositPaymentMethodData memory paymentMethodData = IEscrow(intent.escrow)
            .getDepositPaymentMethodData(intent.depositId, snapshot.paymentMethod);
        require(snapshot.payeeDetails == paymentMethodData.payeeDetails, "UPV: Snapshot payee mismatch");
    }

    /**
     * Nullifies a payment to prevent double-spending
     * @dev Creates a unique nullifier by encoding both the payment method and payment ID together.
     * This prevents collisions where the same payment ID could exist across different payment
     * methods (e.g., Venmo transaction #123 vs PayPal transaction #123).
     */
    function _nullifyPayment(bytes32 paymentMethod, bytes32 paymentId) internal {
        bytes32 nullifier = keccak256(abi.encodePacked(paymentMethod, paymentId));
        _validateAndAddNullifier(nullifier);
    }

    /**
     * Calculates the release amount for an intent by capping the release amount to the intent amount
     */
    function _calculateReleaseAmount(uint256 releaseAmount, uint256 intentAmount) internal pure returns (uint256) {
        if (releaseAmount > intentAmount) {
            return intentAmount;
        }
        return releaseAmount;
    }

    /**
     * Emits the payment details for offchain reconciliation
     */
    function _emitPaymentDetails(bytes32 intentHash, PaymentDetails memory paymentDetails) internal {
        emit PaymentVerified(
            intentHash,                 // Tie the payment details to the intent hash
            paymentDetails.method,
            paymentDetails.currency,
            paymentDetails.amount,
            paymentDetails.timestamp,
            paymentDetails.paymentId,
            paymentDetails.payeeId
        );
    }
}
